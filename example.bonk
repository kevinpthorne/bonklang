mymodule = import; // imports mymodule.bonk
anotherModule = import("test"); // imports test.bonk and aliases it to anotherModule
nestedModule = import("test/"); // imports test/nestModule.bonk

None type = ();
Option<A> type = Some<A> | None; // semantics need to check that 'A' is first declared then used
Ref<A> type = (
	location Int,
	value (): A => read(instance.location) // 'read' must be defined
); // must be defined as primitive type
Array<A> type = (
	location Int = allocate(instance.length), // 'allocate' must be defined
	length Int,
	refOf (offset Int): Ref<A> => instance.location + offset, // semantics need to allow cast here,
	value (offset Int): A => @instance.refOf(offset),
	test (x Int): Int {
		return 4;
	}
);
//see usage in main()

Str type = Array<Char>;

Ew type = Ref<Ref<Int>>;

Status type = Ready | Processing | Done;

//Awful type = Test | (x Int, y Int) | (a Int | None, b Int);
SomeOther type = (
	name Str | None,
	abc Int
);

Person type = (
	name Str,
	address (
		streetname Str,
		city Str
	),
	age Int
);

changeName(person Person, newName Str): Person {
	person.name = newName;
	return person;
};

main() -> None {
	someClosure(): None {
		return;
	};

	result (name Str) = square(5); // should throw on type-mismatch
	result Int = square(5);
	// or even
	result = square(5);


	exampleRef Ref<Int> = \(5);
	inferred = \(5);

	x = 1;

	iDontExist(2, x=1);

	myArray = Array<Int>(5); // if length is static, go on stack -- done by 'allocate'


	if exampleRef.value == 25 {
		print("hello world");
	} else {
		// this would never occur
		print("I should not show up");
	}

	i = 0;
	while i <= 5 {
		i += 1;
	}

	match i {
		5 => print("hello"),
		* => print("else")
	}
};

square(x Int): Int => x^2;

squareIndirect(x Ref<Int>): Ref<Int> => \(\x^2); // the '\' operator calls a primitive function

main();