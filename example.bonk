mymodule = import // imports mymodule.bonk

None type = ()
Option<A> type = Some<A> | None // semantics need to check that 'A' is first declared then used
Ref<A> type = (location Int, value A) // must be defined as primitive type
Array<A> type = (
	refOf (offset Int) -> Ref<A> = instance.startAddr + offset,
	value (offset Int) -> A = \(instance.refOf(offset)),
	startAddr Int,
	length Int = 0,
	test (x Int) -> Int {
		return 4;
	}
)

Str type = Array<Char>

Ew type = Ref<Ref<Int>>

Status type = Ready | Processing | Done

Awful type = Test | (x Int, y Int) | (a Int | None, b Int)
SomeOther type = (
	name Str | None,
	abc Int | (
		x Int,
		y Int
	)
)

Person type = (
	name Str,
	address (
		streetname Str,
		city Str
	),
	age Int
)

changeName(person Person, newName Str) -> Person = {
	person.name = newName;
	return person;
}

main() -> None {
	someClosure() -> None {
		return;
	}

	result (name Str) = square(5); // should throw on type-mismatch
	
	exampleRef Ref<Int> = *(5);


	if exampleRef.value == 25 {
		print("hello world");
	} else {
		// this would never occur
		print("I should not show up");
	}

	i = 0;
	while i <= 5 {
		i += 1;
	}

	match i {
		5 => print("hello"),
		* => print("else")
	}
}

square(x Int) -> Int = x^2;

squareIndirect(x Ref<Int>) -> Ref<Int> = *(\x^2); // the '\' and '*' operators call primitive functions

main();